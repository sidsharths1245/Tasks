<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Task Manager</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">
    <style>
        :root {
            --bg-color: #f4f6f8;
            --card-bg: #ffffff;
            --text-color: #1c1e21;
            --subtext-color: #888;
            --primary-color: #6200ea;
            --danger-color: #ff5252;
            --success-color: #4caf50;
            --info-color: #2196f3;
            --warning-color: #ff9800;
            --tag-bg: #e3f2fd;
            --tag-text: #1976d2;
            --border-radius: 16px;
            --shadow: 0 4px 12px rgba(0,0,0,0.05);
            --font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        body.dark-mode {
            --bg-color: #121212;
            --card-bg: #1e1e1e;
            --text-color: #e4e6eb;
            --subtext-color: #b0b3b8;
            --tag-bg: #1565c0;
            --tag-text: #e3f2fd;
            --shadow: 0 4px 12px rgba(0,0,0,0.5);
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; }
        
        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0; padding: 20px; padding-bottom: 100px;
            overflow-x: hidden; transition: background 0.3s;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        /* --- Header --- */
        header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; }
        h1 { margin: 0; font-size: 1.8rem; font-weight: 800; }

        /* --- Menus --- */
        .menu-container { position: relative; }
        .icon-btn { background: none; border: none; cursor: pointer; color: var(--text-color); padding: 8px; border-radius: 50%; }
        
        .dropdown-menu {
            position: absolute; top: 100%; right: 0;
            background: var(--card-bg); border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            width: 200px; display: none; flex-direction: column; z-index: 2000; overflow: hidden;
        }
        .dropdown-menu.show { display: flex; animation: fadeIn 0.2s; }
        
        .menu-item {
            padding: 15px; background: none; border: none; text-align: left;
            color: var(--text-color); font-size: 1rem; display: flex; align-items: center; gap: 10px; cursor: pointer;
            border-bottom: 1px solid rgba(0,0,0,0.05); width: 100%;
        }
        .menu-item:hover { background: rgba(0,0,0,0.05); }

        .submenu-trigger { position: relative; background: rgba(0,0,0,0.02); }
        .submenu { display: none; background: var(--bg-color); padding: 0; }
        .submenu.open { display: block; }
        .submenu .menu-item { padding-left: 20px; font-size: 0.9rem; border-bottom: 1px solid rgba(0,0,0,0.03); }

        /* --- Section Headers --- */
        .section-title {
            font-size: 0.9rem; color: var(--subtext-color); text-transform: uppercase;
            letter-spacing: 1px; margin: 20px 0 10px; display: flex; align-items: center; gap: 8px;
        }
        .count-badge { background: rgba(0,0,0,0.1); padding: 2px 8px; border-radius: 10px; font-size: 0.8rem; }
        
        .duration-pill {
            background: rgba(98, 0, 234, 0.1); color: var(--primary-color);
            padding: 2px 8px; border-radius: 10px; font-size: 0.75rem; 
            font-weight: 600; letter-spacing: 0; display: inline-flex; align-items: center;
        }
        body.dark-mode .duration-pill { background: rgba(187, 134, 252, 0.15); color: #bb86fc; }

        .sort-container {
            margin-left: auto; display: none; align-items: center; gap: 5px;
            background: var(--primary-color); color: white; 
            padding: 2px 8px; border-radius: 12px;
        }
        .sort-badge { font-size: 0.75rem; text-transform: none; font-weight: 600; }
        .sort-arrow { 
            cursor: pointer; display: flex; align-items: center; 
            font-size: 1.1rem; background: rgba(255,255,255,0.2); border-radius: 50%;
        }
        .sort-arrow:active { background: rgba(255,255,255,0.4); }

        /* --- Task List --- */
        .task-list { list-style: none; padding: 0; margin: 0; position: relative; }

        .task-wrapper {
            position: relative; margin-bottom: 15px; height: auto; min-height: 85px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            background-color: #e0e0e0;
            transform: translate3d(0,0,0); 
            touch-action: pan-y; 
            transition: transform 0.2s;
        }
        
        .drag-clone {
            position: fixed; z-index: 9999;
            pointer-events: none; opacity: 0.95;
            box-shadow: 0 15px 30px rgba(0,0,0,0.3);
            transform-origin: center center;
            border-radius: var(--border-radius);
            transform: scale(1.05);
        }
        .drag-placeholder { opacity: 0; border: 2px dashed var(--primary-color); background: transparent; }
        .task-wrapper.drag-ready { transform: scale(0.98); }

        /* --- Swipe Backgrounds --- */
        .bg-icon {
            position: absolute; top: 0; height: 100%; width: 80px;
            display: flex; align-items: center; justify-content: center;
            color: white; font-size: 2rem; pointer-events: none; opacity: 0;
        }
        .icon-left { left: 0; }
        .icon-right { right: 0; }

        /* --- The Card --- */
        .task-card {
            position: relative; background: var(--card-bg); width: 100%; height: 100%; min-height: 85px;
            z-index: 10; display: flex; align-items: center; padding: 12px 10px 12px 15px;
            border-left: 6px solid transparent; border-radius: var(--border-radius);
            transition: transform 0.1s linear;
            overflow: hidden;
        }

        .priority-high .task-card { border-left-color: var(--danger-color); }
        .priority-med .task-card { border-left-color: var(--warning-color); }
        .priority-low .task-card { border-left-color: var(--success-color); }

        .progress-bar {
            position: absolute; top: 0; left: 0; bottom: 0; width: 100%;
            opacity: 0.15; pointer-events: none; transform-origin: left; z-index: -1;
            transition: transform 1s linear;
        }
        .priority-high .progress-bar { background: var(--danger-color); }
        .priority-med .progress-bar { background: var(--warning-color); }
        .priority-low .progress-bar { background: var(--success-color); }

        .task-info { flex: 1; margin-left: 10px; cursor: pointer; display: flex; flex-direction: column; justify-content: center; }
        .task-name { font-weight: 600; font-size: 1.1rem; display: block; margin-bottom: 4px; }
        .task-time { font-family: monospace; font-size: 0.9rem; color: var(--subtext-color); display: flex; align-items: center; gap: 5px; }
        
        .task-tags-row { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 6px; }
        .card-tag { 
            font-size: 0.7rem; background: var(--tag-bg); color: var(--tag-text); 
            padding: 2px 8px; border-radius: 8px; font-weight: 600;
        }
        .desc-icon { font-size: 14px; color: var(--subtext-color); margin-left: 5px; vertical-align: middle; }

        .card-controls { display: flex; gap: 5px; align-items: center; z-index: 20; }
        
        .btn-mini {
            background: rgba(0,0,0,0.05); border: none; border-radius: 8px;
            width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;
            color: var(--text-color); cursor: pointer;
        }
        .btn-play { color: var(--success-color); background: rgba(76, 175, 80, 0.1); }
        .btn-pause { color: var(--warning-color); background: rgba(255, 152, 0, 0.1); }
        .btn-del { color: var(--danger-color); }
        .btn-reset { color: var(--info-color); }

        /* --- Completed State --- */
        .task-wrapper.completed .task-card { opacity: 0.6; }
        .task-wrapper.completed .task-name { text-decoration: line-through; }
        
        .completed-header { cursor: pointer; user-select: none; }
        .chevron { transition: transform 0.3s; }
        .completed-header.collapsed .chevron { transform: rotate(-90deg); }
        #completedTasksList { transition: max-height 0.3s ease; overflow: hidden; }
        #completedTasksList.hidden { max-height: 0; }

        /* --- Modal Generic --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); z-index: 3000; display: none;
            align-items: center; justify-content: center;
        }
        .modal-overlay.open { display: flex; animation: fadeIn 0.2s; }
        .modal-content {
            background: var(--card-bg); width: 90%; max-width: 400px;
            border-radius: 20px; padding: 25px; animation: slideUp 0.3s;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            max-height: 85vh; overflow-y: auto;
        }

        /* --- Accordion Styles --- */
        .accordion-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 12px 0; cursor: pointer; user-select: none;
            border-bottom: 1px solid rgba(0,0,0,0.05); margin-bottom: 10px;
        }
        .accordion-title {
            font-size: 0.8rem; color: var(--subtext-color); font-weight: 600; 
            text-transform: uppercase; letter-spacing: 0.5px;
        }
        .accordion-summary {
            font-size: 0.8rem; color: var(--primary-color);
            margin-left: auto; margin-right: 10px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            max-width: 120px; font-weight: 500;
        }
        .accordion-icon {
            font-size: 1.2rem; color: var(--subtext-color);
            transition: transform 0.3s ease;
        }
        .accordion-header.active .accordion-icon { transform: rotate(180deg); }
        
        .accordion-content {
            max-height: 0; overflow: hidden; opacity: 0;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
        }
        .accordion-content.open {
            max-height: 300px; opacity: 1; margin-bottom: 15px;
            transition: max-height 0.3s ease-in, opacity 0.3s ease-in;
        }

        /* --- History/Bin Content --- */
        .history-content {
            height: 80vh; max-width: 500px; width: 95%; 
            display: flex; flex-direction: column; overflow: hidden;
        }
        .history-list-container {
            flex: 1; overflow-y: auto; padding-right: 5px; margin-top: 15px;
        }
        .history-date-header {
            font-size: 0.85rem; font-weight: 700; color: var(--primary-color);
            margin: 20px 0 10px 0; border-bottom: 2px solid rgba(0,0,0,0.05);
            padding-bottom: 5px; display: block;
        }
        .history-item {
            display: flex; align-items: center; justify-content: space-between;
            padding: 12px; margin-bottom: 8px; border-radius: 12px;
            background: var(--bg-color); color: var(--text-color);
        }
        .history-item-left { display: flex; flex-direction: column; flex: 1; }
        .history-name { font-weight: 600; font-size: 1rem; }
        .history-meta { font-size: 0.8rem; color: var(--subtext-color); margin-top: 2px; }
        
        .dialog-actions { display: flex; gap: 10px; margin-top: 20px; justify-content: flex-end; }
        .btn-text { background: transparent; color: var(--subtext-color); border: none; font-weight: 600; padding: 10px 15px; border-radius: 8px; cursor: pointer; }
        .btn-primary { background: var(--primary-color); color: white; border: none; font-weight: 600; padding: 10px 20px; border-radius: 8px; cursor: pointer; }
        .btn-danger { background: var(--danger-color); color: white; border: none; font-weight: 600; padding: 10px 20px; border-radius: 8px; cursor: pointer; }

        .form-input, .form-select, .form-textarea {
            width: 100%; padding: 12px; margin-bottom: 10px;
            background: var(--bg-color); border: none; border-radius: 10px; color: var(--text-color);
        }
        .form-textarea { resize: vertical; min-height: 80px; font-family: inherit; }
        .btn-full { width: 100%; padding: 12px; border: none; border-radius: 10px; background: var(--primary-color); color: white; font-weight: bold; cursor: pointer; }
        
        .chip-container { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 15px; }
        .time-chip {
            background: var(--bg-color); border: 1px solid rgba(0,0,0,0.05);
            padding: 5px 10px; border-radius: 15px; font-size: 0.8rem; cursor: pointer;
            color: var(--text-color); transition: background 0.2s;
        }
        .time-chip:active { background: var(--primary-color); color: white; }

        /* Tag Selection Styles */
        .tag-select-container { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 15px; }
        .tag-option {
            background: var(--bg-color); border: 1px solid transparent; color: var(--text-color);
            padding: 6px 12px; border-radius: 20px; font-size: 0.85rem; cursor: pointer;
            transition: all 0.2s;
        }
        .tag-option.selected {
            background: var(--tag-bg); color: var(--tag-text); border-color: var(--tag-text);
        }
        .add-tag-wrapper { display: flex; gap: 8px; margin-bottom: 10px; }

        /* --- Settings List --- */
        .settings-item {
            display: flex; align-items: center; justify-content: space-between;
            padding: 15px; border-radius: 12px; border: 2px solid transparent;
            cursor: pointer; background: var(--bg-color); margin-bottom: 8px;
            transition: all 0.2s;
        }
        .settings-item.active { border-color: var(--primary-color); background: rgba(98, 0, 234, 0.05); }
        body.dark-mode .settings-item.active { background: rgba(187, 134, 252, 0.1); }

        /* --- FAB --- */
        .fab {
            position: fixed; bottom: 30px; right: 30px; width: 60px; height: 60px;
            background-color: var(--primary-color); color: white; border-radius: 50%;
            border: none; box-shadow: 0 4px 15px rgba(98, 0, 234, 0.4);
            display: flex; align-items: center; justify-content: center; z-index: 100;
        }

        @keyframes fadeIn { from{opacity:0} to{opacity:1} }
        @keyframes slideUp { from{transform:translateY(50px)} to{transform:translateY(0)} }
    </style>
</head>
<body>

    <header>
        <h1>Tasks</h1>
        <div class="menu-container">
            <button class="icon-btn" onclick="toggleMenu()">
                <span class="material-icons-round">more_vert</span>
            </button>
            <div id="dropdownMenu" class="dropdown-menu">
                <button class="menu-item submenu-trigger" onclick="toggleSubmenu()">
                    <span class="material-icons-round">sort</span> Sort By...
                    <span class="material-icons-round" style="margin-left:auto; font-size:16px">expand_more</span>
                </button>
                <div id="sortSubmenu" class="submenu">
                    <button class="menu-item" onclick="setSort('priority')">Priority</button>
                    <button class="menu-item" onclick="setSort('duration')">Duration</button>
                    <button class="menu-item" onclick="setSort('manual')">Manual</button>
                </div>

                <button class="menu-item" onclick="openHistory()">
                    <span class="material-icons-round">history</span> History
                </button>
                
                <button class="menu-item" onclick="openDeleted()">
                    <span class="material-icons-round">delete</span> Bin
                </button>

                <button class="menu-item" onclick="openSettings()">
                    <span class="material-icons-round">settings</span> Settings
                </button>
                
                <button class="menu-item" onclick="toggleTheme()">
                    <span class="material-icons-round" id="themeIcon">dark_mode</span>
                    <span id="themeText">Dark Mode</span>
                </button>
                <button class="menu-item" onclick="exportData()">
                    <span class="material-icons-round">download</span> Backup
                </button>
                <button class="menu-item" onclick="document.getElementById('fileInput').click()">
                    <span class="material-icons-round">upload</span> Restore
                </button>
                <input type="file" id="fileInput" hidden onchange="importData(this)">
            </div>
        </div>
    </header>

    <div class="section-title">
        Active 
        <span id="activeCount" class="count-badge">0</span>
        <span id="totalDuration" class="duration-pill">0s</span>
        
        <div id="sortContainer" class="sort-container">
            <span id="sortLabel" class="sort-badge">Priority</span>
            <div class="sort-arrow" onclick="toggleSortDirection()">
                <span id="sortArrowIcon" class="material-icons-round" style="font-size:16px; font-weight:bold;">arrow_downward</span>
            </div>
        </div>
    </div>
    <div id="activeTasksList" class="task-list"></div>

    <div class="section-title completed-header" onclick="toggleCompletedList()">
        <span class="material-icons-round chevron">expand_more</span>
        Completed <span id="completedCount" class="count-badge">0</span>
    </div>
    <div id="completedTasksList" class="task-list"></div>

    <button class="fab" onclick="openModal('add')">
        <span class="material-icons-round" style="font-size:32px">add</span>
    </button>

    <div id="taskModal" class="modal-overlay" onclick="if(event.target===this) closeModal()">
        <div class="modal-content">
            <h2 id="modalTitle" style="margin-top:0">Add Task</h2>
            <input type="hidden" id="taskId">
            
            <label style="font-size:0.8rem; color:var(--subtext-color)">Task Name</label>
            <input type="text" id="taskName" class="form-input" placeholder="Enter name...">
            
            <label style="font-size:0.8rem; color:var(--subtext-color)">Description</label>
            <textarea id="taskDesc" class="form-textarea" placeholder="Notes, links, details..."></textarea>

            <div class="accordion-header" onclick="toggleTagAccordion()">
                <span class="accordion-title">Tags</span>
                <span id="tagSummary" class="accordion-summary">None</span>
                <span id="tagChevron" class="material-icons-round accordion-icon">expand_more</span>
            </div>

            <div id="tagAccordionContent" class="accordion-content">
                <div class="add-tag-wrapper">
                    <input type="text" id="newTagInput" class="form-input" style="margin-bottom:0" placeholder="New tag...">
                    <button class="btn-mini" style="background:var(--primary-color); color:white; width:50px" onclick="addNewTag()">
                        <span class="material-icons-round">add</span>
                    </button>
                </div>
                <div id="tagSelectionArea" class="tag-select-container"></div>
            </div>
            
            <label style="font-size:0.8rem; color:var(--subtext-color)">Duration</label>
            <div class="chip-container">
                <div class="time-chip" onclick="setQuickTime(2)">2m</div>
                <div class="time-chip" onclick="setQuickTime(5)">5m</div>
                <div class="time-chip" onclick="setQuickTime(10)">10m</div>
                <div class="time-chip" onclick="setQuickTime(15)">15m</div>
                <div class="time-chip" onclick="setQuickTime(30)">30m</div>
            </div>
            
            <div style="display:flex; gap:10px;">
                <div style="flex:1">
                    <input type="number" id="taskMin" class="form-input" placeholder="Min" min="0">
                </div>
                <div style="flex:1">
                    <input type="number" id="taskSec" class="form-input" placeholder="Sec" min="0" max="59">
                </div>
            </div>

            <label style="font-size:0.8rem; color:var(--subtext-color)">Priority</label>
            <select id="taskPriority" class="form-select">
                <option value="high">High</option>
                <option value="med">Medium</option>
                <option value="low">Low</option>
            </select>
            
            <button class="btn-full" onclick="saveTask()">Save Task</button>
        </div>
    </div>

    <div id="historyModal" class="modal-overlay" onclick="if(event.target===this) closeHistory()">
        <div class="modal-content history-content">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <h2 style="margin:0">History</h2>
                <button class="btn-mini" onclick="closeHistory()"><span class="material-icons-round">close</span></button>
            </div>
            <p style="font-size:0.8rem; color:var(--subtext-color); margin-top:5px;">Tasks are moved here 24 hours after completion.</p>
            <div id="historyList" class="history-list-container"></div>
            <div style="margin-top:10px;">
                <button class="btn-text" style="color:var(--danger-color); width:100%" onclick="clearHistory()">Clear History</button>
            </div>
        </div>
    </div>

    <div id="deletedModal" class="modal-overlay" onclick="if(event.target===this) closeDeleted()">
        <div class="modal-content history-content">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <h2 style="margin:0">Bin</h2>
                <button class="btn-mini" onclick="closeDeleted()"><span class="material-icons-round">close</span></button>
            </div>
            <p style="font-size:0.8rem; color:var(--subtext-color); margin-top:5px;">Restore tasks or delete them forever.</p>
            <div id="deletedList" class="history-list-container"></div>
            <div style="margin-top:10px;">
                <button class="btn-text" style="color:var(--danger-color); width:100%" onclick="emptyBin()">Empty Bin</button>
            </div>
        </div>
    </div>

    <div id="settingsModal" class="modal-overlay" onclick="if(event.target===this) closeSettings()">
        <div class="modal-content">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <h2 style="margin:0">Settings</h2>
                <button class="btn-mini" onclick="closeSettings()"><span class="material-icons-round">close</span></button>
            </div>
            
            <h4 style="margin:20px 0 10px; color:var(--primary-color)">Notification Sound</h4>
            <div id="tuneList"></div>
            <p style="font-size:0.8rem; color:var(--subtext-color)">Tap to preview and select.</p>
        </div>
    </div>

    <div id="timerDoneModal" class="modal-overlay">
        <div class="modal-content" style="text-align:center">
            <h2 style="margin-top:0">Time's Up!</h2>
            <p id="timerDoneMessage" style="color:var(--text-color); margin-bottom:25px; font-size:1.1rem;"></p>
            
            <div style="display:flex; flex-direction:column; gap:10px">
                <button class="btn-full" style="background:var(--success-color)" id="btnTimerComplete">
                    <span class="material-icons-round" style="vertical-align:middle; font-size:18px; margin-right:5px">check</span> Complete Task
                </button>
                <button class="btn-full" style="background:var(--info-color)" id="btnTimerAdd1">
                    <span class="material-icons-round" style="vertical-align:middle; font-size:18px; margin-right:5px">add</span> +1 Min & Restart
                </button>
                <button class="btn-full" style="background:var(--subtext-color)" id="btnTimerReset">
                    <span class="material-icons-round" style="vertical-align:middle; font-size:18px; margin-right:5px">replay</span> Reset Timer
                </button>
            </div>
        </div>
    </div>

    <div id="dialogModal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="dialogTitle" style="margin-top:0">Confirm</h3>
            <p id="dialogMessage" style="color:var(--text-color); margin-bottom:20px"></p>
            <div class="dialog-actions">
                <button id="dialogCancel" class="btn-text">Cancel</button>
                <button id="dialogConfirm" class="btn-primary">OK</button>
            </div>
        </div>
    </div>

    <script>
        // State
        let tasks = JSON.parse(localStorage.getItem('tasks')) || [];
        let historyTasks = JSON.parse(localStorage.getItem('history')) || [];
        let deletedTasks = JSON.parse(localStorage.getItem('deleted')) || []; 
        let availableTags = JSON.parse(localStorage.getItem('tags')) || ['Work', 'Study', 'Health', 'Errand'];
        let currentTune = localStorage.getItem('tune') || 'beep';
        
        let sortField = localStorage.getItem('sortField') || 'manual';
        let sortOrder = localStorage.getItem('sortOrder') || 'desc';
        
        let currentMode = 'add';
        let currentTimerTask = null;
        let selectedTags = []; // Temp storage for modal
        let wakeLock = null;
        let dialogResolve = null;

        // Run archiving check on startup
        checkArchiving();

        /* --- Audio System --- */
        const audioSystem = {
            ctx: null,
            init: function() {
                if(!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                if(this.ctx.state === 'suspended') this.ctx.resume();
            },
            play: function(type) {
                this.init();
                const ctx = this.ctx;
                const t = ctx.currentTime;
                
                if (type === 'beep') {
                    const o = ctx.createOscillator(); const g = ctx.createGain();
                    o.connect(g); g.connect(ctx.destination);
                    o.type = 'sine'; o.frequency.value = 600;
                    g.gain.setValueAtTime(0.1, t);
                    g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
                    o.start(t); o.stop(t + 0.5);
                } 
                else if (type === 'chime') {
                    [880, 1100, 1320].forEach((freq, i) => {
                        const o = ctx.createOscillator(); const g = ctx.createGain();
                        o.connect(g); g.connect(ctx.destination);
                        o.type = 'sine'; o.frequency.value = freq;
                        const start = t + (i * 0.1);
                        g.gain.setValueAtTime(0, start);
                        g.gain.linearRampToValueAtTime(0.1, start + 0.05);
                        g.gain.exponentialRampToValueAtTime(0.001, start + 1.5);
                        o.start(start); o.stop(start + 1.5);
                    });
                }
                else if (type === 'retro') {
                    const o = ctx.createOscillator(); const g = ctx.createGain();
                    o.connect(g); g.connect(ctx.destination);
                    o.type = 'square'; 
                    o.frequency.setValueAtTime(440, t);
                    o.frequency.linearRampToValueAtTime(880, t + 0.1);
                    o.frequency.setValueAtTime(880, t + 0.1);
                    o.frequency.linearRampToValueAtTime(1760, t + 0.2);
                    g.gain.setValueAtTime(0.05, t);
                    g.gain.linearRampToValueAtTime(0, t + 0.4);
                    o.start(t); o.stop(t + 0.4);
                }
                else if (type === 'warm') {
                    const o = ctx.createOscillator(); const g = ctx.createGain();
                    o.connect(g); g.connect(ctx.destination);
                    o.type = 'triangle'; o.frequency.value = 300;
                    g.gain.setValueAtTime(0, t);
                    g.gain.linearRampToValueAtTime(0.2, t + 0.2); 
                    g.gain.linearRampToValueAtTime(0, t + 1.5);
                    o.start(t); o.stop(t + 1.5);
                }
            }
        };

        /* --- Archiving Logic --- */
        function checkArchiving() {
            const ONE_DAY_MS = 24 * 60 * 60 * 1000; 
            const now = Date.now();
            let changed = false;

            const activeOrRecent = [];
            
            tasks.forEach(task => {
                if(task.completed) {
                    if(!task.completedAt) {
                        task.completedAt = now;
                        changed = true;
                    }
                    if(now - task.completedAt > ONE_DAY_MS) {
                        historyTasks.push(task);
                        changed = true;
                    } else {
                        activeOrRecent.push(task);
                    }
                } else {
                    if(task.completedAt) delete task.completedAt;
                    activeOrRecent.push(task);
                }
            });

            if(changed) {
                tasks = activeOrRecent;
                saveData();
                saveHistory();
            }
        }

        function render() {
            if(document.querySelector('.drag-clone')) return;

            const activeList = document.getElementById('activeTasksList');
            const completedList = document.getElementById('completedTasksList');
            
            activeList.innerHTML = '';
            completedList.innerHTML = '';

            // Update Counts
            const activeTasks = tasks.filter(t => !t.completed);
            document.getElementById('activeCount').innerText = activeTasks.length;
            document.getElementById('completedCount').innerText = tasks.filter(t => t.completed).length;
            const totalSec = activeTasks.reduce((acc, t) => acc + t.remainingTime, 0);
            document.getElementById('totalDuration').innerText = formatTotalDuration(totalSec);

            // Update Sort UI
            const sortCont = document.getElementById('sortContainer');
            if(sortField === 'manual') {
                sortCont.style.display = 'none';
            } else {
                sortCont.style.display = 'flex';
                document.getElementById('sortLabel').innerText = sortField.charAt(0).toUpperCase() + sortField.slice(1);
                document.getElementById('sortArrowIcon').innerText = sortOrder === 'desc' ? 'arrow_downward' : 'arrow_upward';
            }

            // Filter & Sort
            let displayTasks = [...tasks];
            const pMap = {high:3, med:2, low:1};

            if (sortField !== 'manual') {
                displayTasks.sort((a,b) => {
                    if(a.completed !== b.completed) return a.completed - b.completed;
                    let valA, valB;
                    if(sortField === 'priority') {
                        valA = pMap[a.priority];
                        valB = pMap[b.priority];
                    } else { // duration
                        valA = a.remainingTime;
                        valB = b.remainingTime;
                    }
                    return sortOrder === 'asc' ? valA - valB : valB - valA;
                });
            }

            displayTasks.forEach(task => {
                const li = document.createElement('li');
                li.className = `task-wrapper priority-${task.priority} ${task.completed ? 'completed' : ''}`;
                li.setAttribute('data-id', task.id);
                
                const pct = task.originalDuration > 0 ? (task.remainingTime / task.originalDuration) : 0;
                const m = Math.floor(task.remainingTime/60);
                const s = task.remainingTime%60;
                const timeTxt = `${m}m ${s}s`;
                const leftIcon = task.completed ? 'undo' : 'check_circle';

                // Tags HTML
                let tagsHtml = '';
                if (task.tags && task.tags.length > 0) {
                    tagsHtml = `<div class="task-tags-row">
                        ${task.tags.map(tag => `<span class="card-tag">${tag}</span>`).join('')}
                    </div>`;
                }
                
                // Description Icon
                let descIcon = '';
                if(task.desc && task.desc.trim().length > 0) {
                    descIcon = `<span class="material-icons-round desc-icon">description</span>`;
                }

                li.innerHTML = `
                    <div class="bg-icon icon-left"><span class="material-icons-round">${leftIcon}</span></div>
                    <div class="bg-icon icon-right" style="font-size:1.2rem; font-weight:bold; white-space:nowrap;">+1 Min</div>

                    <div class="task-card">
                        <div class="progress-bar" style="transform:scaleX(${pct})"></div>
                        
                        <div class="task-info" onclick="openModal('edit', ${task.id})">
                            <span class="task-name">${task.name} ${descIcon}</span>
                            ${!task.completed ? `<span class="task-time"><span class="material-icons-round" style="font-size:14px">timer</span> ${timeTxt}</span>` : ''}
                            ${tagsHtml}
                        </div>
                        
                        <div class="card-controls">
                            ${!task.completed ? `
                            <button class="btn-mini ${task.isRunning?'btn-pause':'btn-play'}" onclick="event.stopPropagation(); toggleTimer(${task.id})">
                                <span class="material-icons-round">${task.isRunning?'pause':'play_arrow'}</span>
                            </button>
                            <button class="btn-mini btn-reset" onclick="event.stopPropagation(); resetTimer(${task.id})">
                                <span class="material-icons-round">replay</span>
                            </button>
                            ` : ''}
                            <button class="btn-mini btn-del" onclick="event.stopPropagation(); deleteTask(${task.id})">
                                <span class="material-icons-round">delete</span>
                            </button>
                        </div>
                    </div>
                `;

                setupSwipe(li, task);
                if (!task.completed) setupLongPressDrag(li);

                if (task.completed) completedList.appendChild(li);
                else activeList.appendChild(li);
            });
        }

        /* --- History Functions --- */
        function openHistory() {
            document.getElementById('dropdownMenu').classList.remove('show');
            document.getElementById('historyModal').classList.add('open');
            renderHistory();
        }

        function closeHistory() {
            document.getElementById('historyModal').classList.remove('open');
        }

        function renderHistory() {
            const container = document.getElementById('historyList');
            container.innerHTML = '';

            if(historyTasks.length === 0) {
                container.innerHTML = '<div style="text-align:center; margin-top:50px; color:var(--subtext-color)">No history yet</div>';
                return;
            }

            const sortedHistory = [...historyTasks].sort((a,b) => b.completedAt - a.completedAt);
            
            const grouped = {};
            sortedHistory.forEach(task => {
                const dateKey = new Date(task.completedAt).toDateString();
                if(!grouped[dateKey]) grouped[dateKey] = [];
                grouped[dateKey].push(task);
            });

            const today = new Date().toDateString();
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const yestStr = yesterday.toDateString();

            for (const [dateStr, tasks] of Object.entries(grouped)) {
                let displayDate = dateStr;
                if(dateStr === today) displayDate = "Today";
                else if(dateStr === yestStr) displayDate = "Yesterday";
                else displayDate = new Date(dateStr).toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric' });

                const groupDiv = document.createElement('div');
                groupDiv.innerHTML = `<span class="history-date-header">${displayDate}</span>`;
                
                tasks.forEach(t => {
                    const item = document.createElement('div');
                    item.className = 'history-item';
                    const durationM = Math.floor(t.originalDuration / 60);
                    
                    item.innerHTML = `
                        <div class="history-item-left">
                            <span class="history-name">${t.name}</span>
                            <span class="history-meta">Duration: ${durationM}m â€¢ Priority: ${t.priority}</span>
                        </div>
                        <span class="material-icons-round" style="color:var(--success-color)">check</span>
                    `;
                    groupDiv.appendChild(item);
                });
                container.appendChild(groupDiv);
            }
        }

        async function clearHistory() {
            const confirm = await showDialog("Clear History", "Are you sure you want to delete all history permanently?", true, true);
            if(confirm) {
                historyTasks = [];
                saveHistory();
                renderHistory();
            }
        }

        /* --- Bin (Deleted) Functions --- */
        function openDeleted() {
            document.getElementById('dropdownMenu').classList.remove('show');
            document.getElementById('deletedModal').classList.add('open');
            renderDeleted();
        }

        function closeDeleted() {
            document.getElementById('deletedModal').classList.remove('open');
        }

        function renderDeleted() {
            const container = document.getElementById('deletedList');
            container.innerHTML = '';

            if(deletedTasks.length === 0) {
                container.innerHTML = '<div style="text-align:center; margin-top:50px; color:var(--subtext-color)">Bin is empty</div>';
                return;
            }

            const sortedDeleted = [...deletedTasks].sort((a,b) => b.deletedAt - a.deletedAt);

            sortedDeleted.forEach(t => {
                const item = document.createElement('div');
                item.className = 'history-item';
                
                item.innerHTML = `
                    <div class="history-item-left">
                        <span class="history-name" style="text-decoration: line-through; opacity:0.8">${t.name}</span>
                        <span class="history-meta">Priority: ${t.priority}</span>
                    </div>
                    <div style="display:flex; gap:10px">
                        <button class="btn-mini" onclick="restoreTask(${t.id})" style="color:var(--success-color)">
                            <span class="material-icons-round">restore</span>
                        </button>
                        <button class="btn-mini" onclick="permDelete(${t.id})" style="color:var(--danger-color)">
                            <span class="material-icons-round">close</span>
                        </button>
                    </div>
                `;
                container.appendChild(item);
            });
        }

        function restoreTask(id) {
            const t = deletedTasks.find(x => x.id === id);
            if(t) {
                delete t.deletedAt;
                tasks.unshift(t); 
                deletedTasks = deletedTasks.filter(x => x.id !== id);
                saveData(); saveDeleted(); renderDeleted(); render();
            }
        }

        async function permDelete(id) {
            deletedTasks = deletedTasks.filter(x => x.id !== id);
            saveDeleted(); renderDeleted();
        }

        async function emptyBin() {
            const confirm = await showDialog("Empty Bin", "Permanently delete all items in the bin?", true, true);
            if(confirm) {
                deletedTasks = [];
                saveDeleted(); renderDeleted();
            }
        }

        /* --- Settings Functions --- */
        function openSettings() {
            document.getElementById('dropdownMenu').classList.remove('show');
            document.getElementById('settingsModal').classList.add('open');
            renderSettings();
        }

        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('open');
        }

        function renderSettings() {
            const tunes = [
                { id: 'beep', name: 'Standard Beep', icon: 'notifications' },
                { id: 'chime', name: 'Polite Chime', icon: 'notifications_active' },
                { id: 'retro', name: '8-Bit Retro', icon: 'videogame_asset' },
                { id: 'warm', name: 'Warm Ambient', icon: 'spa' }
            ];

            const list = document.getElementById('tuneList');
            list.innerHTML = '';

            tunes.forEach(tune => {
                const div = document.createElement('div');
                div.className = `settings-item ${currentTune === tune.id ? 'active' : ''}`;
                div.onclick = () => selectTune(tune.id);
                
                div.innerHTML = `
                    <div style="display:flex; align-items:center; gap:10px">
                        <span class="material-icons-round" style="color:var(--primary-color)">${tune.icon}</span>
                        <span>${tune.name}</span>
                    </div>
                    ${currentTune === tune.id ? '<span class="material-icons-round" style="color:var(--success-color)">check_circle</span>' : ''}
                `;
                list.appendChild(div);
            });
        }

        function selectTune(id) {
            currentTune = id;
            localStorage.setItem('tune', currentTune);
            renderSettings();
            audioSystem.play(id); 
        }

        /* --- Modal/Dialog --- */
        function showDialog(title, message, isConfirm = true, isDanger = false) {
            return new Promise((resolve) => {
                dialogResolve = resolve;
                document.getElementById('dialogTitle').innerText = title;
                document.getElementById('dialogMessage').innerText = message;
                const btnConfirm = document.getElementById('dialogConfirm');
                const btnCancel = document.getElementById('dialogCancel');
                btnConfirm.className = isDanger ? 'btn-danger' : 'btn-primary';
                btnConfirm.innerText = isConfirm ? 'Yes' : 'OK';
                btnCancel.style.display = isConfirm ? 'block' : 'none';
                document.getElementById('dialogModal').classList.add('open');
            });
        }
        document.getElementById('dialogConfirm').onclick = () => { closeDialog(true); };
        document.getElementById('dialogCancel').onclick = () => { closeDialog(false); };
        function closeDialog(result) {
            document.getElementById('dialogModal').classList.remove('open');
            if (dialogResolve) dialogResolve(result);
            dialogResolve = null;
        }

        function openModal(mode, id) {
            currentMode = mode;
            selectedTags = []; // Reset selected tags
            document.getElementById('taskModal').classList.add('open');
            document.getElementById('modalTitle').innerText = mode==='add'?'Add Task':'Edit Task';
            
            // RESET ACCORDION STATE
            document.getElementById('tagAccordionContent').classList.remove('open');
            document.querySelector('.accordion-header').classList.remove('active');

            if(mode==='edit') {
                const t = tasks.find(x=>x.id===id);
                document.getElementById('taskId').value = t.id;
                document.getElementById('taskName').value = t.name;
                document.getElementById('taskDesc').value = t.desc || '';
                document.getElementById('taskMin').value = Math.floor(t.remainingTime/60);
                document.getElementById('taskSec').value = t.remainingTime%60;
                document.getElementById('taskPriority').value = t.priority;
                if(t.tags) selectedTags = [...t.tags];
            } else {
                document.getElementById('taskId').value = '';
                document.getElementById('taskName').value = '';
                document.getElementById('taskDesc').value = '';
                document.getElementById('taskMin').value = '';
                document.getElementById('taskSec').value = '';
                selectedTags = [];
            }
            renderTagSelection();
        }

        /* --- Tags Logic --- */
        function renderTagSelection() {
            const container = document.getElementById('tagSelectionArea');
            const summary = document.getElementById('tagSummary');
            
            container.innerHTML = '';
            
            if (selectedTags.length === 0) {
                summary.innerText = "None";
                summary.style.color = "var(--subtext-color)";
            } else {
                summary.innerText = selectedTags.join(", ");
                summary.style.color = "var(--primary-color)";
            }

            availableTags.forEach(tag => {
                const div = document.createElement('div');
                div.className = `tag-option ${selectedTags.includes(tag) ? 'selected' : ''}`;
                div.innerText = tag;
                div.onclick = () => {
                    if(selectedTags.includes(tag)) selectedTags = selectedTags.filter(t => t !== tag);
                    else selectedTags.push(tag);
                    renderTagSelection();
                };
                container.appendChild(div);
            });
        }
        
        function toggleTagAccordion() {
            const content = document.getElementById('tagAccordionContent');
            const header = document.querySelector('.accordion-header');
            
            if (content.classList.contains('open')) {
                content.classList.remove('open');
                header.classList.remove('active');
            } else {
                content.classList.add('open');
                header.classList.add('active');
            }
        }

        function addNewTag() {
            const input = document.getElementById('newTagInput');
            const val = input.value.trim();
            if(val && !availableTags.includes(val)) {
                availableTags.push(val);
                selectedTags.push(val); // Auto-select created tag
                localStorage.setItem('tags', JSON.stringify(availableTags));
                input.value = '';
                renderTagSelection();
            }
        }

        function setQuickTime(m) {
            document.getElementById('taskMin').value = m;
            document.getElementById('taskSec').value = 0;
        }
        
        function saveTask() {
            const name = document.getElementById('taskName').value;
            const desc = document.getElementById('taskDesc').value;
            const min = parseInt(document.getElementById('taskMin').value)||0;
            const sec = parseInt(document.getElementById('taskSec').value)||0;
            const prio = document.getElementById('taskPriority').value;
            const id = parseInt(document.getElementById('taskId').value);
            const totalSec = (min*60) + sec;
            
            if(currentMode === 'add') {
                tasks.unshift({
                    id: Date.now(), name: name, desc: desc, priority: prio,
                    tags: [...selectedTags],
                    originalDuration: totalSec, remainingTime: totalSec,
                    completed: false, isRunning: false
                });
            } else {
                const t = tasks.find(x=>x.id===id);
                if(t) {
                    t.name = name; t.desc = desc; t.priority = prio;
                    t.tags = [...selectedTags];
                    if(t.remainingTime !== totalSec && Math.abs(t.remainingTime - totalSec) > 5) {
                        t.remainingTime = totalSec; t.originalDuration = totalSec;
                    }
                }
            }
            saveData(); closeModal(); render();
        }
        function closeModal() { document.getElementById('taskModal').classList.remove('open'); }
        function toggleMenu() { document.getElementById('dropdownMenu').classList.toggle('show'); document.getElementById('sortSubmenu').classList.remove('open'); }
        function toggleSubmenu() { document.getElementById('sortSubmenu').classList.toggle('open'); }
        window.onclick = e => { if(!e.target.closest('.menu-container')) document.getElementById('dropdownMenu').classList.remove('show'); }
        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            document.getElementById('themeText').innerText = isDark ? "Light Mode" : "Dark Mode";
            document.getElementById('themeIcon').innerText = isDark ? "light_mode" : "dark_mode";
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
        }
        if(localStorage.getItem('theme')==='dark') toggleTheme();
        function toggleCompletedList() {
            document.getElementById('completedTasksList').classList.toggle('hidden');
            document.querySelector('.completed-header').classList.toggle('collapsed');
        }
        function saveData() { localStorage.setItem('tasks', JSON.stringify(tasks)); }
        function saveHistory() { localStorage.setItem('history', JSON.stringify(historyTasks)); }
        function saveDeleted() { localStorage.setItem('deleted', JSON.stringify(deletedTasks)); }
        
        function exportData() {
            const data = { tasks: tasks, history: historyTasks, deleted: deletedTasks, tune: currentTune, tags: availableTags };
            const a = document.createElement('a');
            a.href = "data:text/json;charset=utf-8,"+encodeURIComponent(JSON.stringify(data));
            a.download='tasks_backup.json'; a.click();
        }
        function importData(inp) {
            const r=new FileReader(); 
            r.onload=e=>{
                const data = JSON.parse(e.target.result);
                if(Array.isArray(data)) {
                    tasks = data; 
                } else {
                    tasks = data.tasks || [];
                    historyTasks = data.history || [];
                    deletedTasks = data.deleted || [];
                    if(data.tune) currentTune = data.tune;
                    if(data.tags) availableTags = data.tags;
                }
                saveData(); saveHistory(); saveDeleted(); localStorage.setItem('tags', JSON.stringify(availableTags)); render();
            };
            r.readAsText(inp.files[0]);
        }
        /* --- Sorting --- */
        function setSort(field) {
            sortField = field;
            if(field === 'priority') sortOrder = 'desc';
            else if(field === 'duration') sortOrder = 'asc';
            localStorage.setItem('sortField', sortField);
            localStorage.setItem('sortOrder', sortOrder);
            render();
            document.getElementById('dropdownMenu').classList.remove('show');
        }
        function toggleSortDirection() {
            sortOrder = sortOrder === 'asc' ? 'desc' : 'asc';
            localStorage.setItem('sortOrder', sortOrder);
            render();
        }

        /* --- Notifications Helper --- */
        function requestNotificationPermission() {
            if ("Notification" in window && Notification.permission !== "granted") {
                Notification.requestPermission();
            }
        }
        function sendNotification(title, body) {
            if ("Notification" in window && Notification.permission === "granted") {
                try {
                    new Notification(title, { body: body, icon: 'https://cdn-icons-png.flaticon.com/512/2098/2098589.png' });
                } catch(e) { console.log("Notif error", e); }
            }
        }

        /* --- Timer Done Modal Logic --- */
        function openTimerDoneModal(task) {
            currentTimerTask = task;
            document.getElementById('timerDoneMessage').innerText = `"${task.name}" is finished.`;
            document.getElementById('timerDoneModal').classList.add('open');
        }

        function closeTimerDoneModal() {
            document.getElementById('timerDoneModal').classList.remove('open');
            currentTimerTask = null;
        }

        document.getElementById('btnTimerComplete').onclick = () => {
            if(currentTimerTask) toggleComplete(currentTimerTask.id);
            closeTimerDoneModal();
        };

        document.getElementById('btnTimerAdd1').onclick = () => {
            if(currentTimerTask) {
                addTime(currentTimerTask.id); 
                const t = tasks.find(x => x.id === currentTimerTask.id);
                if(t) { 
                    t.isRunning = true; 
                    reqWL(); 
                    saveData(); 
                    render(); 
                }
            }
            closeTimerDoneModal();
        };

        document.getElementById('btnTimerReset').onclick = () => {
            if(currentTimerTask) resetTimer(currentTimerTask.id);
            closeTimerDoneModal();
        };

        /* --- Main Loop --- */
        setInterval(() => {
            let u = false;
            let activeTask = null;

            tasks.forEach(t => {
                if(t.isRunning && t.remainingTime > 0) {
                    activeTask = t;
                    t.remainingTime--; 
                    u = true;
                    if(t.remainingTime === 0) { 
                        t.isRunning = false; 
                        audioSystem.play(currentTune); 
                        sendNotification("Timer Finished", `Completed: ${t.name}`);
                        openTimerDoneModal(t); 
                        relWL(); 
                    }
                }
            });

            if(activeTask) {
                const m = Math.floor(activeTask.remainingTime/60);
                const s = activeTask.remainingTime%60;
                const paddedS = s < 10 ? '0'+s : s;
                document.title = `(${m}:${paddedS}) ${activeTask.name}`;
            } else {
                document.title = "Task Manager";
            }

            if(u) {
                saveData(); 
                render();
            }
        }, 1000);

        function formatTotalDuration(seconds) {
            if (seconds === 0) return '0s';
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = seconds % 60;
            if (h > 0) return `${h}h ${m}m ${s}s`;
            if (m > 0) return `${m}m ${s}s`;
            return `${s}s`;
        }

        /* --- Input Handling --- */
        function setupLongPressDrag(li) {
            let pressTimer;
            let startX, startY;
            const PRESS_DURATION = 500;

            const startPress = (e) => {
                if(e.target.closest('button')) return;
                const touch = e.touches ? e.touches[0] : e;
                startX = touch.clientX;
                startY = touch.clientY;

                pressTimer = setTimeout(async () => {
                    if(sortField !== 'manual') {
                        const confirmSwitch = await showDialog("Sort Locked", "Switch to Manual sort to reorder items?", true);
                        if(confirmSwitch) setSort('manual');
                        return;
                    }
                    if(navigator.vibrate) navigator.vibrate(50);
                    li.classList.add('drag-ready');
                    initDrag(e, li, startY);
                }, PRESS_DURATION);
            };

            const cancelPress = () => {
                clearTimeout(pressTimer);
                li.classList.remove('drag-ready');
            };

            const checkMove = (e) => {
                const touch = e.touches ? e.touches[0] : e;
                const moveX = Math.abs(touch.clientX - startX);
                const moveY = Math.abs(touch.clientY - startY);
                if(moveX > 10 || moveY > 10) cancelPress();
            };

            li.addEventListener('touchstart', startPress, {passive: true});
            li.addEventListener('mousedown', startPress);
            li.addEventListener('touchmove', checkMove, {passive: true});
            li.addEventListener('mousemove', checkMove);
            li.addEventListener('touchend', cancelPress);
            li.addEventListener('mouseup', cancelPress);
        }

        function initDrag(e, li, initialY) {
            let isDragging = true;
            let clone = null;
            let startY = initialY;
            const rect = li.getBoundingClientRect();
            const offsetY = startY - rect.top;
            
            clone = li.cloneNode(true);
            clone.classList.add('drag-clone');
            clone.classList.remove('drag-ready');
            clone.style.width = rect.width + 'px';
            clone.style.height = rect.height + 'px';
            clone.style.top = rect.top + 'px';
            clone.style.left = rect.left + 'px';
            clone.removeAttribute('data-id');
            document.body.appendChild(clone);
            
            li.classList.add('drag-placeholder');

            const move = (e) => {
                if(!isDragging || !clone) return;
                e.preventDefault();
                const touch = e.touches ? e.touches[0] : e;
                const currentY = touch.clientY;
                const newTop = currentY - offsetY;
                clone.style.top = `${newTop}px`;
                clone.style.transform = 'scale(1.05)';

                const centerX = rect.left + (rect.width/2);
                const centerY = newTop + (rect.height/2);
                clone.style.display = 'none';
                let elemBelow = document.elementFromPoint(centerX, centerY);
                clone.style.display = 'block';

                if(!elemBelow) return;
                const closestLi = elemBelow.closest('.task-wrapper');
                if (closestLi && closestLi !== li && closestLi.parentNode.id === 'activeTasksList') {
                    const parent = li.parentNode;
                    const children = [...parent.children];
                    const curIndex = children.indexOf(li);
                    const targetIndex = children.indexOf(closestLi);
                    if(curIndex < targetIndex) parent.insertBefore(li, closestLi.nextSibling);
                    else parent.insertBefore(li, closestLi);
                }
            };

            const end = (e) => {
                if(!isDragging) return;
                isDragging = false;
                if(clone) { clone.remove(); clone = null; }
                li.classList.remove('drag-placeholder');
                li.classList.remove('drag-ready');
                updateOrder();
                document.removeEventListener('touchmove', move);
                document.removeEventListener('mousemove', move);
                document.removeEventListener('touchend', end);
                document.removeEventListener('mouseup', end);
            };

            document.addEventListener('touchmove', move, {passive: false});
            document.addEventListener('mousemove', move);
            document.addEventListener('touchend', end);
            document.addEventListener('mouseup', end);
        }

        function updateOrder() {
            const activeIds = [...document.getElementById('activeTasksList').children].map(el => parseInt(el.getAttribute('data-id')));
            const compIds = [...document.getElementById('completedTasksList').children].map(el => parseInt(el.getAttribute('data-id')));
            const newTasks = [];
            activeIds.forEach(id => newTasks.push(tasks.find(t=>t.id===id)));
            compIds.forEach(id => newTasks.push(tasks.find(t=>t.id===id)));
            tasks = newTasks;
            saveData();
        }

        function setupSwipe(li, task) {
            const card = li.querySelector('.task-card');
            let startX=0, startY=0, currentX=0;
            let isSwiping = false, isScrolling = false;

            card.addEventListener('touchstart', e => {
                if(li.classList.contains('drag-placeholder')) return;
                startX = e.touches[0].clientX; 
                startY = e.touches[0].clientY;
                isSwiping = false; isScrolling = false;
                card.style.transition = 'none';
            });

            card.addEventListener('touchmove', e => {
                if(li.classList.contains('drag-placeholder') || li.classList.contains('drag-ready')) return;
                if(isScrolling) return;

                const touch = e.touches[0];
                const deltaX = touch.clientX - startX;
                const deltaY = touch.clientY - startY;

                if (!isSwiping) {
                    if (Math.abs(deltaY) > Math.abs(deltaX)) { isScrolling = true; return; }
                    if (Math.abs(deltaX) > 10) { isSwiping = true; } else { return; }
                }

                if(e.cancelable) e.preventDefault();
                currentX = deltaX;
                if(currentX > 100) currentX = 100;
                if(currentX < -100) currentX = -100;

                const iconL = li.querySelector('.icon-left');
                const iconR = li.querySelector('.icon-right');

                if(currentX > 0) {
                    li.style.backgroundColor = 'var(--success-color)';
                    iconL.style.opacity = Math.min(1, currentX/50);
                    if(iconR) iconR.style.opacity = 0;
                } else if (currentX < 0 && !task.completed) {
                    li.style.backgroundColor = 'var(--info-color)';
                    if(iconR) iconR.style.opacity = Math.min(1, Math.abs(currentX)/50);
                    iconL.style.opacity = 0;
                }
                card.style.transform = `translateX(${currentX}px)`;
            });

            card.addEventListener('touchend', () => {
                isSwiping = false; isScrolling = false;
                card.style.transition = 'transform 0.3s ease';
                li.style.transition = 'background-color 0.3s';
                
                if(currentX > 60) {
                    toggleComplete(task.id);
                } else if (currentX < -60 && !task.completed) {
                    addTime(task.id);
                    setTimeout(() => { card.style.transform = 'translateX(0)'; li.style.backgroundColor = '#e0e0e0'; }, 300);
                    return; 
                }
                card.style.transform = 'translateX(0)';
                li.querySelectorAll('.bg-icon').forEach(i => i.style.opacity=0);
                currentX = 0;
            });
        }

        function resetTimer(id) {
            const t = tasks.find(x => x.id === id);
            if(t) {
                t.remainingTime = t.originalDuration;
                t.isRunning = false;
                saveData(); render();
            }
        }
        function toggleComplete(id) {
            const t = tasks.find(x=>x.id===id);
            if(t) {
                t.completed = !t.completed; 
                t.isRunning = false;
                if(!t.completed) {
                    t.remainingTime = t.originalDuration;
                    delete t.completedAt; // Remove timestamp if undone
                } else {
                    t.completedAt = Date.now(); // Set timestamp
                }
                saveData(); render();
            }
        }
        function addTime(id) {
            const t = tasks.find(x=>x.id===id);
            if(t) {
                t.remainingTime += 60;
                t.originalDuration = Math.max(t.originalDuration, t.remainingTime);
                saveData(); render();
            }
        }
        function toggleTimer(id) {
            audioSystem.init(); 
            requestNotificationPermission(); 
            const t = tasks.find(x=>x.id===id);
            if(!t.isRunning) {
                tasks.forEach(x => x.isRunning = false);
                t.isRunning = true; reqWL();
            } else { t.isRunning = false; relWL(); }
            saveData(); 
            render();
        }
        
        async function deleteTask(id) {
            const confirmDelete = await showDialog("Move to Bin", "Move this task to the bin?", true, true);
            if(confirmDelete) { 
                const t = tasks.find(x => x.id === id);
                if(t) {
                    t.deletedAt = Date.now();
                    t.isRunning = false;
                    deletedTasks.push(t);
                    tasks = tasks.filter(x=>x.id!==id); 
                    saveData(); saveDeleted(); render(); 
                }
            }
        }

        async function reqWL(){ try{wakeLock=await navigator.wakeLock.request('screen');}catch(e){} }
        function relWL(){ if(wakeLock){wakeLock.release(); wakeLock=null;} }

        render();
    </script>
</body>
</html>

