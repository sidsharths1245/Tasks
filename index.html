<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Task Manager</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">
    <style>
        :root {
            --bg-color: #f4f6f8;
            --card-bg: #ffffff;
            --text-color: #1c1e21;
            --subtext-color: #888;
            --primary-color: #6200ea;
            --danger-color: #ff5252;
            --success-color: #4caf50;
            --info-color: #2196f3;
            --warning-color: #ff9800;
            --border-radius: 16px;
            --shadow: 0 4px 12px rgba(0,0,0,0.05);
            --font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        body.dark-mode {
            --bg-color: #121212;
            --card-bg: #1e1e1e;
            --text-color: #e4e6eb;
            --subtext-color: #b0b3b8;
            --shadow: 0 4px 12px rgba(0,0,0,0.5);
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; }
        
        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0; padding: 20px; padding-bottom: 100px;
            overflow-x: hidden; transition: background 0.3s;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        /* --- Header --- */
        header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; }
        h1 { margin: 0; font-size: 1.8rem; font-weight: 800; }

        /* --- Menus --- */
        .menu-container { position: relative; }
        .icon-btn { background: none; border: none; cursor: pointer; color: var(--text-color); padding: 8px; border-radius: 50%; }
        
        .dropdown-menu {
            position: absolute; top: 100%; right: 0;
            background: var(--card-bg); border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            width: 200px; display: none; flex-direction: column; z-index: 2000; overflow: hidden;
        }
        .dropdown-menu.show { display: flex; animation: fadeIn 0.2s; }
        
        .menu-item {
            padding: 15px; background: none; border: none; text-align: left;
            color: var(--text-color); font-size: 1rem; display: flex; align-items: center; gap: 10px; cursor: pointer;
            border-bottom: 1px solid rgba(0,0,0,0.05); width: 100%;
        }
        .menu-item:hover { background: rgba(0,0,0,0.05); }

        .submenu-trigger { position: relative; background: rgba(0,0,0,0.02); }
        .submenu { display: none; background: var(--bg-color); padding: 0; }
        .submenu.open { display: block; }
        .submenu .menu-item { padding-left: 20px; font-size: 0.9rem; border-bottom: 1px solid rgba(0,0,0,0.03); }

        /* --- Section Headers --- */
        .section-title {
            font-size: 0.9rem; color: var(--subtext-color); text-transform: uppercase;
            letter-spacing: 1px; margin: 20px 0 10px; display: flex; align-items: center; gap: 8px;
        }
        .count-badge { background: rgba(0,0,0,0.1); padding: 2px 8px; border-radius: 10px; font-size: 0.8rem; }
        
        .duration-pill {
            background: rgba(98, 0, 234, 0.1); color: var(--primary-color);
            padding: 2px 8px; border-radius: 10px; font-size: 0.75rem; 
            font-weight: 600; letter-spacing: 0; display: inline-flex; align-items: center;
        }
        body.dark-mode .duration-pill { background: rgba(187, 134, 252, 0.15); color: #bb86fc; }

        .sort-container {
            margin-left: auto; display: none; align-items: center; gap: 5px;
            background: var(--primary-color); color: white; 
            padding: 2px 8px; border-radius: 12px;
        }
        .sort-badge { font-size: 0.75rem; text-transform: none; font-weight: 600; }
        .sort-arrow { 
            cursor: pointer; display: flex; align-items: center; 
            font-size: 1.1rem; background: rgba(255,255,255,0.2); border-radius: 50%;
        }
        .sort-arrow:active { background: rgba(255,255,255,0.4); }

        /* --- Task List --- */
        .task-list { list-style: none; padding: 0; margin: 0; position: relative; }

        .task-wrapper {
            position: relative; margin-bottom: 15px; height: 85px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            background-color: #e0e0e0;
            transform: translate3d(0,0,0); 
            touch-action: pan-y; 
            transition: transform 0.2s;
        }
        
        .drag-clone {
            position: fixed; z-index: 9999;
            pointer-events: none; opacity: 0.95;
            box-shadow: 0 15px 30px rgba(0,0,0,0.3);
            transform-origin: center center;
            border-radius: var(--border-radius);
            transform: scale(1.05);
        }
        .drag-placeholder { opacity: 0; border: 2px dashed var(--primary-color); background: transparent; }
        .task-wrapper.drag-ready { transform: scale(0.98); }

        /* --- Swipe Backgrounds --- */
        .bg-icon {
            position: absolute; top: 0; height: 100%; width: 80px;
            display: flex; align-items: center; justify-content: center;
            color: white; font-size: 2rem; pointer-events: none; opacity: 0;
        }
        .icon-left { left: 0; }
        .icon-right { right: 0; }

        /* --- The Card --- */
        .task-card {
            position: relative; background: var(--card-bg); width: 100%; height: 100%;
            z-index: 10; display: flex; align-items: center; padding: 0 10px 0 15px;
            border-left: 6px solid transparent; border-radius: var(--border-radius);
            transition: transform 0.1s linear;
            overflow: hidden;
        }

        .priority-high .task-card { border-left-color: var(--danger-color); }
        .priority-med .task-card { border-left-color: var(--warning-color); }
        .priority-low .task-card { border-left-color: var(--success-color); }

        .progress-bar {
            position: absolute; top: 0; left: 0; bottom: 0; width: 100%;
            opacity: 0.15; pointer-events: none; transform-origin: left; z-index: -1;
            transition: transform 1s linear;
        }
        .priority-high .progress-bar { background: var(--danger-color); }
        .priority-med .progress-bar { background: var(--warning-color); }
        .priority-low .progress-bar { background: var(--success-color); }

        .task-info { flex: 1; margin-left: 10px; cursor: pointer; }
        .task-name { font-weight: 600; font-size: 1.1rem; display: block; margin-bottom: 4px; }
        .task-time { font-family: monospace; font-size: 0.9rem; color: var(--subtext-color); display: flex; align-items: center; gap: 5px; }

        .card-controls { display: flex; gap: 5px; align-items: center; z-index: 20; }
        
        .btn-mini {
            background: rgba(0,0,0,0.05); border: none; border-radius: 8px;
            width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;
            color: var(--text-color); cursor: pointer;
        }
        .btn-play { color: var(--success-color); background: rgba(76, 175, 80, 0.1); }
        .btn-pause { color: var(--warning-color); background: rgba(255, 152, 0, 0.1); }
        .btn-del { color: var(--danger-color); }
        .btn-reset { color: var(--info-color); }

        /* --- Completed State --- */
        .task-wrapper.completed .task-card { opacity: 0.6; }
        .task-wrapper.completed .task-name { text-decoration: line-through; }
        
        .completed-header { cursor: pointer; user-select: none; }
        .chevron { transition: transform 0.3s; }
        .completed-header.collapsed .chevron { transform: rotate(-90deg); }
        #completedTasksList { transition: max-height 0.3s ease; overflow: hidden; }
        #completedTasksList.hidden { max-height: 0; }

        /* --- Modal Generic --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); z-index: 3000; display: none;
            align-items: center; justify-content: center;
        }
        .modal-overlay.open { display: flex; animation: fadeIn 0.2s; }
        .modal-content {
            background: var(--card-bg); width: 90%; max-width: 400px;
            border-radius: 20px; padding: 25px; animation: slideUp 0.3s;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        /* --- History Modal Specifics --- */
        .history-content {
            height: 80vh; max-width: 500px; width: 95%; 
            display: flex; flex-direction: column; overflow: hidden;
        }
        .history-list-container {
            flex: 1; overflow-y: auto; padding-right: 5px; margin-top: 15px;
        }
        .history-date-header {
            font-size: 0.85rem; font-weight: 700; color: var(--primary-color);
            margin: 20px 0 10px 0; border-bottom: 2px solid rgba(0,0,0,0.05);
            padding-bottom: 5px; display: block;
        }
        .history-item {
            display: flex; align-items: center; justify-content: space-between;
            padding: 12px; margin-bottom: 8px; border-radius: 12px;
            background: var(--bg-color); color: var(--text-color);
        }
        .history-item-left { display: flex; flex-direction: column; }
        .history-name { font-weight: 600; font-size: 1rem; }
        .history-meta { font-size: 0.8rem; color: var(--subtext-color); margin-top: 2px; }
        
        .dialog-actions { display: flex; gap: 10px; margin-top: 20px; justify-content: flex-end; }
        .btn-text { background: transparent; color: var(--subtext-color); border: none; font-weight: 600; padding: 10px 15px; border-radius: 8px; cursor: pointer; }
        .btn-primary { background: var(--primary-color); color: white; border: none; font-weight: 600; padding: 10px 20px; border-radius: 8px; cursor: pointer; }
        .btn-danger { background: var(--danger-color); color: white; border: none; font-weight: 600; padding: 10px 20px; border-radius: 8px; cursor: pointer; }

        .form-input, .form-select {
            width: 100%; padding: 12px; margin-bottom: 10px;
            background: var(--bg-color); border: none; border-radius: 10px; color: var(--text-color);
        }
        .btn-full { width: 100%; padding: 12px; border: none; border-radius: 10px; background: var(--primary-color); color: white; font-weight: bold; }
        
        .chip-container { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 15px; }
        .time-chip {
            background: var(--bg-color); border: 1px solid rgba(0,0,0,0.05);
            padding: 5px 10px; border-radius: 15px; font-size: 0.8rem; cursor: pointer;
            color: var(--text-color); transition: background 0.2s;
        }
        .time-chip:active { background: var(--primary-color); color: white; }

        /* --- FAB --- */
        .fab {
            position: fixed; bottom: 30px; right: 30px; width: 60px; height: 60px;
            background-color: var(--primary-color); color: white; border-radius: 50%;
            border: none; box-shadow: 0 4px 15px rgba(98, 0, 234, 0.4);
            display: flex; align-items: center; justify-content: center; z-index: 100;
        }

        @keyframes fadeIn { from{opacity:0} to{opacity:1} }
        @keyframes slideUp { from{transform:translateY(50px)} to{transform:translateY(0)} }
    </style>
</head>
<body>

    <header>
        <h1>Tasks</h1>
        <div class="menu-container">
            <button class="icon-btn" onclick="toggleMenu()">
                <span class="material-icons-round">more_vert</span>
            </button>
            <div id="dropdownMenu" class="dropdown-menu">
                <button class="menu-item submenu-trigger" onclick="toggleSubmenu()">
                    <span class="material-icons-round">sort</span> Sort By...
                    <span class="material-icons-round" style="margin-left:auto; font-size:16px">expand_more</span>
                </button>
                <div id="sortSubmenu" class="submenu">
                    <button class="menu-item" onclick="setSort('priority')">Priority</button>
                    <button class="menu-item" onclick="setSort('duration')">Duration</button>
                    <button class="menu-item" onclick="setSort('manual')">Manual</button>
                </div>

                <button class="menu-item" onclick="openHistory()">
                    <span class="material-icons-round">history</span> History
                </button>
                
                <button class="menu-item" onclick="toggleTheme()">
                    <span class="material-icons-round" id="themeIcon">dark_mode</span>
                    <span id="themeText">Dark Mode</span>
                </button>
                <button class="menu-item" onclick="exportData()">
                    <span class="material-icons-round">download</span> Backup
                </button>
                <button class="menu-item" onclick="document.getElementById('fileInput').click()">
                    <span class="material-icons-round">upload</span> Restore
                </button>
                <input type="file" id="fileInput" hidden onchange="importData(this)">
            </div>
        </div>
    </header>

    <div class="section-title">
        Active 
        <span id="activeCount" class="count-badge">0</span>
        <span id="totalDuration" class="duration-pill">0s</span>
        
        <div id="sortContainer" class="sort-container">
            <span id="sortLabel" class="sort-badge">Priority</span>
            <div class="sort-arrow" onclick="toggleSortDirection()">
                <span id="sortArrowIcon" class="material-icons-round" style="font-size:16px; font-weight:bold;">arrow_downward</span>
            </div>
        </div>
    </div>
    <div id="activeTasksList" class="task-list"></div>

    <div class="section-title completed-header" onclick="toggleCompletedList()">
        <span class="material-icons-round chevron">expand_more</span>
        Completed <span id="completedCount" class="count-badge">0</span>
    </div>
    <div id="completedTasksList" class="task-list"></div>

    <button class="fab" onclick="openModal('add')">
        <span class="material-icons-round" style="font-size:32px">add</span>
    </button>

    <div id="taskModal" class="modal-overlay" onclick="if(event.target===this) closeModal()">
        <div class="modal-content">
            <h2 id="modalTitle" style="margin-top:0">Add Task</h2>
            <input type="hidden" id="taskId">
            
            <label style="font-size:0.8rem; color:var(--subtext-color)">Task Name</label>
            <input type="text" id="taskName" class="form-input" placeholder="Enter name...">
            
            <label style="font-size:0.8rem; color:var(--subtext-color)">Duration</label>
            <div class="chip-container">
                <div class="time-chip" onclick="setQuickTime(2)">2m</div>
                <div class="time-chip" onclick="setQuickTime(5)">5m</div>
                <div class="time-chip" onclick="setQuickTime(10)">10m</div>
                <div class="time-chip" onclick="setQuickTime(15)">15m</div>
                <div class="time-chip" onclick="setQuickTime(30)">30m</div>
            </div>
            
            <div style="display:flex; gap:10px;">
                <div style="flex:1">
                    <input type="number" id="taskMin" class="form-input" placeholder="Min" min="0">
                </div>
                <div style="flex:1">
                    <input type="number" id="taskSec" class="form-input" placeholder="Sec" min="0" max="59">
                </div>
            </div>

            <label style="font-size:0.8rem; color:var(--subtext-color)">Priority</label>
            <select id="taskPriority" class="form-select">
                <option value="high">High</option>
                <option value="med">Medium</option>
                <option value="low">Low</option>
            </select>
            
            <button class="btn-full" onclick="saveTask()">Save Task</button>
        </div>
    </div>

    <div id="historyModal" class="modal-overlay" onclick="if(event.target===this) closeHistory()">
        <div class="modal-content history-content">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <h2 style="margin:0">History</h2>
                <button class="btn-mini" onclick="closeHistory()"><span class="material-icons-round">close</span></button>
            </div>
            <p style="font-size:0.8rem; color:var(--subtext-color); margin-top:5px;">Tasks are moved here 24 hours after completion.</p>
            
            <div id="historyList" class="history-list-container">
                </div>
            
            <div style="margin-top:10px;">
                <button class="btn-text" style="color:var(--danger-color); width:100%" onclick="clearHistory()">Clear History</button>
            </div>
        </div>
    </div>

    <div id="dialogModal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="dialogTitle" style="margin-top:0">Confirm</h3>
            <p id="dialogMessage" style="color:var(--text-color); margin-bottom:20px"></p>
            <div class="dialog-actions">
                <button id="dialogCancel" class="btn-text">Cancel</button>
                <button id="dialogConfirm" class="btn-primary">OK</button>
            </div>
        </div>
    </div>

    <script>
        // State
        let tasks = JSON.parse(localStorage.getItem('tasks')) || [];
        let historyTasks = JSON.parse(localStorage.getItem('history')) || [];
        
        let sortField = localStorage.getItem('sortField') || 'manual';
        let sortOrder = localStorage.getItem('sortOrder') || 'desc';
        
        let currentMode = 'add';
        let wakeLock = null;
        let audioCtx;
        let dialogResolve = null;

        // Run archiving check on startup
        checkArchiving();

        /* --- Archiving Logic --- */
        function checkArchiving() {
            const ONE_DAY_MS = 24 * 60 * 60 * 1000; 
            const now = Date.now();
            let changed = false;

            const activeOrRecent = [];
            
            tasks.forEach(task => {
                if(task.completed) {
                    // Ensure legacy tasks have a timestamp
                    if(!task.completedAt) {
                        task.completedAt = now;
                        changed = true;
                    }
                    
                    // Check if 24 hours have passed
                    if(now - task.completedAt > ONE_DAY_MS) {
                        historyTasks.push(task);
                        changed = true;
                    } else {
                        activeOrRecent.push(task);
                    }
                } else {
                    // If task was un-completed, ensure no timestamp
                    if(task.completedAt) delete task.completedAt;
                    activeOrRecent.push(task);
                }
            });

            if(changed) {
                tasks = activeOrRecent;
                saveData();
                saveHistory();
            }
        }

        function render() {
            if(document.querySelector('.drag-clone')) return;

            const activeList = document.getElementById('activeTasksList');
            const completedList = document.getElementById('completedTasksList');
            
            activeList.innerHTML = '';
            completedList.innerHTML = '';

            // Update Counts
            const activeTasks = tasks.filter(t => !t.completed);
            document.getElementById('activeCount').innerText = activeTasks.length;
            document.getElementById('completedCount').innerText = tasks.filter(t => t.completed).length;
            const totalSec = activeTasks.reduce((acc, t) => acc + t.remainingTime, 0);
            document.getElementById('totalDuration').innerText = formatTotalDuration(totalSec);

            // Update Sort UI
            const sortCont = document.getElementById('sortContainer');
            if(sortField === 'manual') {
                sortCont.style.display = 'none';
            } else {
                sortCont.style.display = 'flex';
                document.getElementById('sortLabel').innerText = sortField.charAt(0).toUpperCase() + sortField.slice(1);
                document.getElementById('sortArrowIcon').innerText = sortOrder === 'desc' ? 'arrow_downward' : 'arrow_upward';
            }

            // Filter & Sort
            let displayTasks = [...tasks];
            const pMap = {high:3, med:2, low:1};

            if (sortField !== 'manual') {
                displayTasks.sort((a,b) => {
                    if(a.completed !== b.completed) return a.completed - b.completed;
                    let valA, valB;
                    if(sortField === 'priority') {
                        valA = pMap[a.priority];
                        valB = pMap[b.priority];
                    } else { // duration
                        valA = a.remainingTime;
                        valB = b.remainingTime;
                    }
                    return sortOrder === 'asc' ? valA - valB : valB - valA;
                });
            }

            displayTasks.forEach(task => {
                const li = document.createElement('li');
                li.className = `task-wrapper priority-${task.priority} ${task.completed ? 'completed' : ''}`;
                li.setAttribute('data-id', task.id);
                
                const pct = task.originalDuration > 0 ? (task.remainingTime / task.originalDuration) : 0;
                const m = Math.floor(task.remainingTime/60);
                const s = task.remainingTime%60;
                const timeTxt = `${m}m ${s}s`;
                const leftIcon = task.completed ? 'undo' : 'check_circle';

                li.innerHTML = `
                    <div class="bg-icon icon-left"><span class="material-icons-round">${leftIcon}</span></div>
                    <div class="bg-icon icon-right" style="font-size:1.2rem; font-weight:bold; white-space:nowrap;">+1 Min</div>

                    <div class="task-card">
                        <div class="progress-bar" style="transform:scaleX(${pct})"></div>
                        
                        <div class="task-info" onclick="openModal('edit', ${task.id})">
                            <span class="task-name">${task.name}</span>
                            ${!task.completed ? `<span class="task-time"><span class="material-icons-round" style="font-size:14px">timer</span> ${timeTxt}</span>` : ''}
                        </div>
                        
                        <div class="card-controls">
                            ${!task.completed ? `
                            <button class="btn-mini ${task.isRunning?'btn-pause':'btn-play'}" onclick="event.stopPropagation(); toggleTimer(${task.id})">
                                <span class="material-icons-round">${task.isRunning?'pause':'play_arrow'}</span>
                            </button>
                            <button class="btn-mini btn-reset" onclick="event.stopPropagation(); resetTimer(${task.id})">
                                <span class="material-icons-round">replay</span>
                            </button>
                            ` : ''}
                            <button class="btn-mini btn-del" onclick="event.stopPropagation(); deleteTask(${task.id})">
                                <span class="material-icons-round">delete</span>
                            </button>
                        </div>
                    </div>
                `;

                setupSwipe(li, task);
                if (!task.completed) setupLongPressDrag(li);

                if (task.completed) completedList.appendChild(li);
                else activeList.appendChild(li);
            });
        }

        /* --- History Functions --- */
        function openHistory() {
            document.getElementById('dropdownMenu').classList.remove('show');
            document.getElementById('historyModal').classList.add('open');
            renderHistory();
        }

        function closeHistory() {
            document.getElementById('historyModal').classList.remove('open');
        }

        function renderHistory() {
            const container = document.getElementById('historyList');
            container.innerHTML = '';

            if(historyTasks.length === 0) {
                container.innerHTML = '<div style="text-align:center; margin-top:50px; color:var(--subtext-color)">No history yet</div>';
                return;
            }

            // Sort by completion date (descending)
            const sortedHistory = [...historyTasks].sort((a,b) => b.completedAt - a.completedAt);
            
            // Group by date
            const grouped = {};
            sortedHistory.forEach(task => {
                const dateKey = new Date(task.completedAt).toDateString();
                if(!grouped[dateKey]) grouped[dateKey] = [];
                grouped[dateKey].push(task);
            });

            // Helpers for Date Headers
            const today = new Date().toDateString();
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const yestStr = yesterday.toDateString();

            for (const [dateStr, tasks] of Object.entries(grouped)) {
                let displayDate = dateStr;
                if(dateStr === today) displayDate = "Today";
                else if(dateStr === yestStr) displayDate = "Yesterday";
                else displayDate = new Date(dateStr).toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric' });

                const groupDiv = document.createElement('div');
                groupDiv.innerHTML = `<span class="history-date-header">${displayDate}</span>`;
                
                tasks.forEach(t => {
                    const item = document.createElement('div');
                    item.className = 'history-item';
                    
                    const durationM = Math.floor(t.originalDuration / 60);
                    
                    item.innerHTML = `
                        <div class="history-item-left">
                            <span class="history-name">${t.name}</span>
                            <span class="history-meta">Duration: ${durationM}m â€¢ Priority: ${t.priority}</span>
                        </div>
                        <span class="material-icons-round" style="color:var(--success-color)">check</span>
                    `;
                    groupDiv.appendChild(item);
                });
                
                container.appendChild(groupDiv);
            }
        }

        async function clearHistory() {
            const confirm = await showDialog("Clear History", "Are you sure you want to delete all history permanently?", true, true);
            if(confirm) {
                historyTasks = [];
                saveHistory();
                renderHistory();
            }
        }

        function formatTotalDuration(seconds) {
            if (seconds === 0) return '0s';
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = seconds % 60;
            if (h > 0) return `${h}h ${m}m ${s}s`;
            if (m > 0) return `${m}m ${s}s`;
            return `${s}s`;
        }

        /* --- Input Handling --- */
        function setupLongPressDrag(li) {
            let pressTimer;
            let startX, startY;
            const PRESS_DURATION = 500;

            const startPress = (e) => {
                if(e.target.closest('button')) return;
                const touch = e.touches ? e.touches[0] : e;
                startX = touch.clientX;
                startY = touch.clientY;

                pressTimer = setTimeout(async () => {
                    if(sortField !== 'manual') {
                        const confirmSwitch = await showDialog("Sort Locked", "Switch to Manual sort to reorder items?", true);
                        if(confirmSwitch) setSort('manual');
                        return;
                    }
                    if(navigator.vibrate) navigator.vibrate(50);
                    li.classList.add('drag-ready');
                    initDrag(e, li, startY);
                }, PRESS_DURATION);
            };

            const cancelPress = () => {
                clearTimeout(pressTimer);
                li.classList.remove('drag-ready');
            };

            const checkMove = (e) => {
                const touch = e.touches ? e.touches[0] : e;
                const moveX = Math.abs(touch.clientX - startX);
                const moveY = Math.abs(touch.clientY - startY);
                if(moveX > 10 || moveY > 10) cancelPress();
            };

            li.addEventListener('touchstart', startPress, {passive: true});
            li.addEventListener('mousedown', startPress);
            li.addEventListener('touchmove', checkMove, {passive: true});
            li.addEventListener('mousemove', checkMove);
            li.addEventListener('touchend', cancelPress);
            li.addEventListener('mouseup', cancelPress);
        }

        function initDrag(e, li, initialY) {
            let isDragging = true;
            let clone = null;
            let startY = initialY;
            const rect = li.getBoundingClientRect();
            const offsetY = startY - rect.top;
            
            clone = li.cloneNode(true);
            clone.classList.add('drag-clone');
            clone.classList.remove('drag-ready');
            clone.style.width = rect.width + 'px';
            clone.style.height = rect.height + 'px';
            clone.style.top = rect.top + 'px';
            clone.style.left = rect.left + 'px';
            clone.removeAttribute('data-id');
            document.body.appendChild(clone);
            
            li.classList.add('drag-placeholder');

            const move = (e) => {
                if(!isDragging || !clone) return;
                e.preventDefault();
                const touch = e.touches ? e.touches[0] : e;
                const currentY = touch.clientY;
                const newTop = currentY - offsetY;
                clone.style.top = `${newTop}px`;
                clone.style.transform = 'scale(1.05)';

                const centerX = rect.left + (rect.width/2);
                const centerY = newTop + (rect.height/2);
                clone.style.display = 'none';
                let elemBelow = document.elementFromPoint(centerX, centerY);
                clone.style.display = 'block';

                if(!elemBelow) return;
                const closestLi = elemBelow.closest('.task-wrapper');
                if (closestLi && closestLi !== li && closestLi.parentNode.id === 'activeTasksList') {
                    const parent = li.parentNode;
                    const children = [...parent.children];
                    const curIndex = children.indexOf(li);
                    const targetIndex = children.indexOf(closestLi);
                    if(curIndex < targetIndex) parent.insertBefore(li, closestLi.nextSibling);
                    else parent.insertBefore(li, closestLi);
                }
            };

            const end = (e) => {
                if(!isDragging) return;
                isDragging = false;
                if(clone) { clone.remove(); clone = null; }
                li.classList.remove('drag-placeholder');
                li.classList.remove('drag-ready');
                updateOrder();
                document.removeEventListener('touchmove', move);
                document.removeEventListener('mousemove', move);
                document.removeEventListener('touchend', end);
                document.removeEventListener('mouseup', end);
            };

            document.addEventListener('touchmove', move, {passive: false});
            document.addEventListener('mousemove', move);
            document.addEventListener('touchend', end);
            document.addEventListener('mouseup', end);
        }

        function updateOrder() {
            const activeIds = [...document.getElementById('activeTasksList').children].map(el => parseInt(el.getAttribute('data-id')));
            const compIds = [...document.getElementById('completedTasksList').children].map(el => parseInt(el.getAttribute('data-id')));
            const newTasks = [];
            activeIds.forEach(id => newTasks.push(tasks.find(t=>t.id===id)));
            compIds.forEach(id => newTasks.push(tasks.find(t=>t.id===id)));
            tasks = newTasks;
            saveData();
        }

        function setupSwipe(li, task) {
            const card = li.querySelector('.task-card');
            let startX=0, startY=0, currentX=0;
            let isSwiping = false, isScrolling = false;

            card.addEventListener('touchstart', e => {
                if(li.classList.contains('drag-placeholder')) return;
                startX = e.touches[0].clientX; 
                startY = e.touches[0].clientY;
                isSwiping = false; isScrolling = false;
                card.style.transition = 'none';
            });

            card.addEventListener('touchmove', e => {
                if(li.classList.contains('drag-placeholder') || li.classList.contains('drag-ready')) return;
                if(isScrolling) return;

                const touch = e.touches[0];
                const deltaX = touch.clientX - startX;
                const deltaY = touch.clientY - startY;

                if (!isSwiping) {
                    if (Math.abs(deltaY) > Math.abs(deltaX)) { isScrolling = true; return; }
                    if (Math.abs(deltaX) > 10) { isSwiping = true; } else { return; }
                }

                if(e.cancelable) e.preventDefault();
                currentX = deltaX;
                if(currentX > 100) currentX = 100;
                if(currentX < -100) currentX = -100;

                const iconL = li.querySelector('.icon-left');
                const iconR = li.querySelector('.icon-right');

                if(currentX > 0) {
                    li.style.backgroundColor = 'var(--success-color)';
                    iconL.style.opacity = Math.min(1, currentX/50);
                    if(iconR) iconR.style.opacity = 0;
                } else if (currentX < 0 && !task.completed) {
                    li.style.backgroundColor = 'var(--info-color)';
                    if(iconR) iconR.style.opacity = Math.min(1, Math.abs(currentX)/50);
                    iconL.style.opacity = 0;
                }
                card.style.transform = `translateX(${currentX}px)`;
            });

            card.addEventListener('touchend', () => {
                isSwiping = false; isScrolling = false;
                card.style.transition = 'transform 0.3s ease';
                li.style.transition = 'background-color 0.3s';
                
                if(currentX > 60) {
                    toggleComplete(task.id);
                } else if (currentX < -60 && !task.completed) {
                    addTime(task.id);
                    setTimeout(() => { card.style.transform = 'translateX(0)'; li.style.backgroundColor = '#e0e0e0'; }, 300);
                    return; 
                }
                card.style.transform = 'translateX(0)';
                li.querySelectorAll('.bg-icon').forEach(i => i.style.opacity=0);
                currentX = 0;
            });
        }

        function resetTimer(id) {
            const t = tasks.find(x => x.id === id);
            if(t) {
                t.remainingTime = t.originalDuration;
                t.isRunning = false;
                saveData(); render();
            }
        }
        function toggleComplete(id) {
            const t = tasks.find(x=>x.id===id);
            if(t) {
                t.completed = !t.completed; 
                t.isRunning = false;
                if(!t.completed) {
                    t.remainingTime = t.originalDuration;
                    delete t.completedAt; // Remove timestamp if undone
                } else {
                    t.completedAt = Date.now(); // Set timestamp
                }
                saveData(); render();
            }
        }
        function addTime(id) {
            const t = tasks.find(x=>x.id===id);
            if(t) {
                t.remainingTime += 60;
                t.originalDuration = Math.max(t.originalDuration, t.remainingTime);
                saveData(); render();
            }
        }
        function toggleTimer(id) {
            initAudio();
            const t = tasks.find(x=>x.id===id);
            if(!t.isRunning) {
                tasks.forEach(x => x.isRunning = false);
                t.isRunning = true; reqWL();
            } else { t.isRunning = false; relWL(); }
            render();
        }
        async function deleteTask(id) {
            const confirmDelete = await showDialog("Delete Task", "Are you sure you want to delete this task?", true, true);
            if(confirmDelete) { tasks = tasks.filter(x=>x.id!==id); saveData(); render(); }
        }

        /* --- Modal/Dialog --- */
        function showDialog(title, message, isConfirm = true, isDanger = false) {
            return new Promise((resolve) => {
                dialogResolve = resolve;
                document.getElementById('dialogTitle').innerText = title;
                document.getElementById('dialogMessage').innerText = message;
                const btnConfirm = document.getElementById('dialogConfirm');
                const btnCancel = document.getElementById('dialogCancel');
                btnConfirm.className = isDanger ? 'btn-danger' : 'btn-primary';
                btnConfirm.innerText = isConfirm ? 'Yes' : 'OK';
                btnCancel.style.display = isConfirm ? 'block' : 'none';
                document.getElementById('dialogModal').classList.add('open');
            });
        }
        document.getElementById('dialogConfirm').onclick = () => { closeDialog(true); };
        document.getElementById('dialogCancel').onclick = () => { closeDialog(false); };
        function closeDialog(result) {
            document.getElementById('dialogModal').classList.remove('open');
            if (dialogResolve) dialogResolve(result);
            dialogResolve = null;
        }

        function openModal(mode, id) {
            currentMode = mode;
            document.getElementById('taskModal').classList.add('open');
            document.getElementById('modalTitle').innerText = mode==='add'?'Add Task':'Edit Task';
            if(mode==='edit') {
                const t = tasks.find(x=>x.id===id);
                document.getElementById('taskId').value = t.id;
                document.getElementById('taskName').value = t.name;
                document.getElementById('taskMin').value = Math.floor(t.remainingTime/60);
                document.getElementById('taskSec').value = t.remainingTime%60;
                document.getElementById('taskPriority').value = t.priority;
            } else {
                document.getElementById('taskId').value = '';
                document.getElementById('taskName').value = '';
                document.getElementById('taskMin').value = '';
                document.getElementById('taskSec').value = '';
            }
        }
        function setQuickTime(m) {
            document.getElementById('taskMin').value = m;
            document.getElementById('taskSec').value = 0;
        }
        function saveTask() {
            const name = document.getElementById('taskName').value;
            const min = parseInt(document.getElementById('taskMin').value)||0;
            const sec = parseInt(document.getElementById('taskSec').value)||0;
            const prio = document.getElementById('taskPriority').value;
            const id = parseInt(document.getElementById('taskId').value);
            const totalSec = (min*60) + sec;
            if(currentMode === 'add') {
                tasks.unshift({
                    id: Date.now(), name: name, priority: prio,
                    originalDuration: totalSec, remainingTime: totalSec,
                    completed: false, isRunning: false
                });
            } else {
                const t = tasks.find(x=>x.id===id);
                if(t) {
                    t.name = name; t.priority = prio;
                    if(t.remainingTime !== totalSec && Math.abs(t.remainingTime - totalSec) > 5) {
                        t.remainingTime = totalSec; t.originalDuration = totalSec;
                    }
                }
            }
            saveData(); closeModal(); render();
        }
        function closeModal() { document.getElementById('taskModal').classList.remove('open'); }
        function toggleMenu() { document.getElementById('dropdownMenu').classList.toggle('show'); document.getElementById('sortSubmenu').classList.remove('open'); }
        function toggleSubmenu() { document.getElementById('sortSubmenu').classList.toggle('open'); }
        window.onclick = e => { if(!e.target.closest('.menu-container')) document.getElementById('dropdownMenu').classList.remove('show'); }
        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            document.getElementById('themeText').innerText = isDark ? "Light Mode" : "Dark Mode";
            document.getElementById('themeIcon').innerText = isDark ? "light_mode" : "dark_mode";
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
        }
        if(localStorage.getItem('theme')==='dark') toggleTheme();
        function toggleCompletedList() {
            document.getElementById('completedTasksList').classList.toggle('hidden');
            document.querySelector('.completed-header').classList.toggle('collapsed');
        }
        function saveData() { localStorage.setItem('tasks', JSON.stringify(tasks)); }
        function saveHistory() { localStorage.setItem('history', JSON.stringify(historyTasks)); }
        function exportData() {
            const data = { tasks: tasks, history: historyTasks };
            const a = document.createElement('a');
            a.href = "data:text/json;charset=utf-8,"+encodeURIComponent(JSON.stringify(data));
            a.download='tasks_backup.json'; a.click();
        }
        function importData(inp) {
            const r=new FileReader(); 
            r.onload=e=>{
                const data = JSON.parse(e.target.result);
                if(Array.isArray(data)) {
                    tasks = data; // Legacy support
                } else {
                    tasks = data.tasks || [];
                    historyTasks = data.history || [];
                }
                saveData(); saveHistory(); render();
            };
            r.readAsText(inp.files[0]);
        }
        /* --- Sorting --- */
        function setSort(field) {
            sortField = field;
            if(field === 'priority') sortOrder = 'desc';
            else if(field === 'duration') sortOrder = 'asc';
            localStorage.setItem('sortField', sortField);
            localStorage.setItem('sortOrder', sortOrder);
            render();
            document.getElementById('dropdownMenu').classList.remove('show');
        }
        function toggleSortDirection() {
            sortOrder = sortOrder === 'asc' ? 'desc' : 'asc';
            localStorage.setItem('sortOrder', sortOrder);
            render();
        }

        setInterval(() => {
            let u=false;
            tasks.forEach(t => {
                if(t.isRunning && t.remainingTime>0) {
                    t.remainingTime--; u=true;
                    if(t.remainingTime===0) { 
                        t.isRunning=false; 
                        playSound(); 
                        showDialog("Timer Done", "Task completed: " + t.name, false); 
                        relWL(); 
                    }
                }
            });
            if(u) render();
        }, 1000);

        function initAudio(){ if(!audioCtx) audioCtx=new(window.AudioContext||window.webkitAudioContext)(); }
        function playSound(){
            initAudio(); const o=audioCtx.createOscillator(); const g=audioCtx.createGain();
            o.connect(g); g.connect(audioCtx.destination); o.type='sine'; o.frequency.value=600;
            g.gain.value=0.1; o.start(); o.stop(audioCtx.currentTime+0.5);
            if(navigator.vibrate) navigator.vibrate(200);
        }
        async function reqWL(){ try{wakeLock=await navigator.wakeLock.request('screen');}catch(e){} }
        function relWL(){ if(wakeLock){wakeLock.release(); wakeLock=null;} }

        render();
    </script>
</body>
</html>

